# Chiascript by example

*This is not a final specification. This is an elucidation of ideas.*

Funds are encumbered by a puzzle script, which looks like a LISP S-expression. An S-expression is recursively defined as either an atom (either a binary blob or a "free variable x_k", one of `x0, x1, ...`), or a list of S-expressions.

The binary blob is untyped, but functions expect the blobs to be parsed and interpreted as particular data types (such as integers, booleans, public keys, or packed S-expressions).

A puzzle script loosely represents boolean expressions in values `x0, x1, ... x_n` that can replaced with literals and simplified.


## Examples of atoms

```scheme
  100   ; two's complement integer, compiles to the binary blob `binascii.unhexlify("64")`
  0x64  ; also compiles to `binascii.unhexlify("64")`
  x1    ; the free variable x1
  x7    ; the free variable x7
```

All atoms are typed as binary blobs.


## Examples of lists

```scheme
  (100 0x65 0x68656c6c6f) ; a list of three blobs
  (0x64 101 'hello')      ; a list of the same three blobs
```

(the two lists above are identical, and will compiled to the same output)

```scheme
  (equal (100 (+ 99 1)))
  (equal x1 (+ x2 5))
```

The "equal" atom is actually a specific blob (of length 1) that corresponds to they keyword "equal", and has a specific meaning during evaluation.


## reduce (formerly know as "eval")

These lists don't do much by themselves; they're just data structures. But, as in bitcoin, we can provide "witnesses", values for `x0, x1, ..., x_n` that show that we can "solve" the puzzle. Often this will involve just a signature, but it can also involve hash reveals or other tricks. Normally, "running" a LISP program uses a function called "eval", but we will call it "reduce" to emphasize the fact that all we are doing is simplifying expressions and removing branches already proven true and no longer relevant.

Invoking "reduce" takes a list of literal values for some or all of `x0, x1, ..., x_n`

```scheme
(reduce ((equal 100 x0)) (0x64))
    => (equal 100 0x64)
    => T   ; T is a synonym for 0x01

(reduce ((equal x0 (+ x1 x2))) (15 5 10))
    => (equal 15 (+ 5 10))
    => (equal 15 15)
    => T

(reduce ((equal x0 (+ x1 x2))) (x0 5 10))
    => (equal x0 (+ 5 10))
    => (equal x0 15)
```

In the last case, the reduction cannot be continued any further without a binding to `x0`. (It's pretty obvious that setting `x0` to 15 would finish "solving" this puzzle script.)


## More Operators

We've already informally introduced "+" and "equal", which have obvious functionality (side note: "equal" compares blobs as blobs, not as integers, which may have multiple blob representations). Here are a few more operators with their reductions:

```scheme
(+ 1 2) => 3
(- 6 5) => 1
(* 2 4 5) => 40
(/ 72 8) => 9
(sha256 0x00 0x01)
  => python: hashlib.sha256(binascii.unhexlify("0001")).digest()
  => 0xb413f47d13ee2fe6c845b2ee141af81de858df4ec549a58b7970bb96645bc8d2
```

## Signatures

It's rather pointless encumbering assets without a digital signature somewhere, since signatures are the only things that might contain restrictions that miners cannot simply modify to their benefit (ie. steal the funds). We introduce an operator that checks a signature.

### aggsig

Since we intend to use BLS signatures, which can be aggregated, we can't check signatures immediately, but instead must defer checking until later, possibly much later.

This means we don't want to call the operator `checksig` as in bitcoin, because we're deferring validation. Instezd, we call it `aggsig` for "aggregate signature".

```scheme
(aggsig x0 x1) ; "aggregate signature"
  ; x0 is the public key and x1 is the hashed value that we claim has been signed
  ; BLS lets us create a single aggregated signature that proves validity of all contained signatures
  ; and it lets us do so non-interactively (so it can be done by the block generator, for example)
```

If `x0` and `x1` can vary however we want, this is a pretty easy condition to satisfy. So we must ensure the public key is a particular value.

```scheme
  (
   (aggsig x0 x1)
   (equal x0 0x0317f1d3a73197d7942695638c4...86c55e83ff97a1aeffb3af00adb22c6bb)
  )
```

(We introduce an implicit "and" of two conditions here.) This pair of conditions at least requires the pubkey to be something specific. However, it places no restrictions on the outputs, so miners can still steal the funds. We need to include a restriction on the outputs.

Also, it seems wasteful to have to set `x0` equal to a constant that is already in the script. We'll have to deal with this too.

### assert_output

```scheme
  (assert_output x0 x1 x2) ; where x0, x1, x2 are blobs representing outputs that MUST exist
```

We're getting closer. But how can we tie this to a signature? For this, we need to include "reduce" in the language.

### reduce

```scheme
  (reduce x0 x1)
```

This unwraps the blob in x0 as a script, and applies "reduce" to it using the bindings in x1, which is interpreted as a list of values.


## All together now: a first crack at a pay-to-address

```scheme
  ((aggsig x0 x1)
   (equal x0 0x0317f1d3a73197d7942695638c4...86c55e83ff97a1aeffb3af00adb22c6bb)
   (reduce x1 x2)
  )
```

We set `x0` equal to the pubkey, and sign a script `x1` that contains something like
```scheme
  (assert_output K0 K1 K2) ; where K0 K1 K2 are constants that represent outputs that MUST exist
```

and we finally have a solution `(x0, x1)` that miners cannot change because the signature is tied to particular outputs.

Note, however, that the signature only depends upon the *outputs*. We also need the signature to depend upon the input, so that two unspents with the same pay-to-script can't be unlocked with the same witnesses. So although `x1` *must* change the message we sign, we may want other information mixed in there too, like the input and the exact location within the script.


## 1 of 2

### chose1

At first, we might consider creating an operator `or` which acts as the boolean operator countering `and`. However, since signature evaluation is deferred for aggregation, this causes a problem. If we have an `or` that has signature evaluations in each branch, we have two separate possible aggregations. This doesn't seem like much, but if aggregation is done over multiple inputs over multiple transactions, we get exponential blow-up: for example, after 100 similar `or` branches, we have $2^{100}$ potential combinations, which is clearly intractable.

Instead, we propose a `chose1` operator, which takes as its first parameter, an index indicating which subexpression to collapse to. It's like an `or` that requires the witness branch chosen to be explicitly stated.

[We might also consider a generalized `choseN` operator.]

Using `chose1`, here is a 1-of-2.

```scheme
  ((chose1 x0
    (equal x1 0x0317f1d3a73197d7942695638c4...86c55e83ff97a1aeffb3af00adb22c6bb)
    (equal x1 0x020572cbea904d67468808c8eb5...ae28f75bb8f1c7c42c39a8c5529bf0f4e)
    )
   (aggsig x1 x2)
   (reduce x2 x3)
  )
```

- `x0` = 0 or 1, depending upon which pubkey we want to sign
- `x1` = the pubkey
- `x2` = the conditions being signed
- `x3` = the solution to the conditions


## Graftroot

If we encumber funds using something like the above, a Graftroot falls out immediately. Instead of signing `assert_output`, we can sign any child script. It may include another `aggsig`, delegating the details to another signer. This is the core of Graftroot functionality proposed in bitcoin.


## Taproot

Taproot involves creating a synthetic public key that is the sum of a public key with a known private key, and the public key generated by a script. Given a public key `P` on a group with generator `G`, and a script `S`, we instead encumber the funds using the public key `P1 = P + G * hash(P || S)`.

Taproot allows the script to be redeemed if either the condition `S` becomes true, or the a signature is generated on pubkey `P`. The underlying script might look something like this:

```scheme
  ((choose1 x0
     ((aggsig x1 x2) ; standard branch
      (reduce x2 x3)
     )
     ((equal x4 (point_add x1 x3)) ; taproot branch
      (equal x3 (pubkey_for_exp (hash x1 x2)))
      (reduce x2 x5)
     )
   )
   (equal x1 0x0317f1d3a73197d7942695638c4...86c55e83ff97a1aeffb3af00adb22c6bb) ; x1 = P1 = P + hash(P||S)
  )
```

- x0 = 0 for regular signature, 1 for taproot
- x1 = P1

standard branch:
- x2 = script to sign
- x3 = proof of x2

taproot branch:
- x2 = S
- x3 = hash(P || S)
- x4 = P
- x5 = proof of S

The main benefit of Taproot is that contracts can be completely hidden. This benefit is largest when all users of pay-to-address use scripts of this form. Since this form is much larger than a simpler version, to encourage its use, we will need to provide a discount to scripts of this form.


## macros

Being LISP-ish, we can develop macros that do simple expansion in a pretty obvious way.

Note that the free variables `x0`, `x1`, etc. here mean something different: they are string-substituted with the S-expressions passed in their place. Macros are evaulated at compile time, not at "run-time" (ie. when "reduce" is applied).

```scheme
  (macro pay_to_taproot (P x0 x1 x2 x3 x4 x5)
   (choose1 x0
     ((aggsig x1 x2) ; standard branch
      (reduce x2 x3)
     )
     ((equal x4 (point_add x1 x3)) ; taproot branch
      (equal x3 (pubkey_for_exp (hash x1 x2)))
      (reduce x2 x5)
     )
   )
   (equal x1 P) ; x1 = P1 = P + hash(P||S)
  )
```

Then to expand a taproot branch, we can pass to the compiler

```scheme
   (pay_to_taproot 0x0317f1d3a73197d7942695638c4...86c55e83ff97a1aeffb3af00adb22c6bb x0 x1 x2 x3 x4 x5 x6)
```

When compiling a statement, we now need a macro context. The compiler can decide for itself how it will do this.

Macros don't decrease the size or complexity of a compiled script; their main goal is to improve readability for humans by hiding repeated details.

When using the taproot expansion from here on out, we will use this macro.

We will also use

```scheme
  (macro pay_to_pubkey (x0 x1 x2)
    ((aggsig x0 x1) (reduce x1 x2))
  )
```

for encapsulating a simple public key encumberance.


## multisig

BLS signatures support a "native" multisig that collapse down to and appear indistinguishable from a regular signature. But even without this property, would could write multisig contracts easily. Here is a 3-of-5, for example:

```scheme
  (
   (pay_to_pubkey x0 x1 x2)
   (pay_to_pubkey x3 x4 x5)
   (pay_to_pubkey x6 x7 x8)
   (((not (equal x0 x3)) (not (equal x0 x6)) (not (equal x3 x6)))) ; ensure all pubkeys are different
   (members (  ; ensure that each of the three keys used are in the blessed list of five
     0x0317f1d3a73197d7942695638c4...86c55e83ff97a1aeffb3af00adb22c6bb
     0x020572cbea904d67468808c8eb5...ae28f75bb8f1c7c42c39a8c5529bf0f4e
     0x0309ece308f9d1f0131765212de...981747a0b2ca2179b96d2c0c9024e5224
     0x030c9b60d5afcbd5663a8a44b7c...97feb04decc694b13e08587f3ff9b5b60
     0x0210e7791fb972fe014159aa33a...7a91a8c46e59a00dca575af0f18fb13dc
   ) x0 x3 x6)
  )
```

You could team this up with taproot, but notice the number of potential witnesses increases.

```scheme
  (
   (pay_to_taproot  x0  x1  x2  x3  x4  x5  x6  x7)
   (pay_to_taproot  x8  x9 x10 x11 x12 x13 x14 x15)
   (pay_to_taproot x16 x17 x18 x19 x20 x21 x22 x23)
   (((not (equal x0 x8)) (not (equal x0 x16)) (not (equal x8 x16)))) ; ensure all pubkeys are different
   (members (
     0x0317f1d3a73197d7942695638c4...86c55e83ff97a1aeffb3af00adb22c6bb
     0x020572cbea904d67468808c8eb5...ae28f75bb8f1c7c42c39a8c5529bf0f4e
     0x0309ece308f9d1f0131765212de...981747a0b2ca2179b96d2c0c9024e5224
     0x030c9b60d5afcbd5663a8a44b7c...97feb04decc694b13e08587f3ff9b5b60
     0x0210e7791fb972fe014159aa33a...7a91a8c46e59a00dca575af0f18fb13dc
   ) x0 x3 x6)
  )
```

Here we need up to 24 witness.


## hash reuse: what exactly is being signed?

A signature on a private key contains a list of constraints and possibly other script operators. However, if these items are the only items that the signature is signing, we run the risk of transplanting the signature to other scripts that validate the same private key. This is beneficial for proving that arbitrary signatures are created, but can cause problems if multiple outputs are encumbered by the same key. So we need a way to mix in information about the current output, as well as the relative location of this operand within the script so we can guarantee that `mix-in` can create a unique hash value to be signed.

`(mix-in)`

We might consider parameters to the mix-in, indicating whether we include the hash id of the output, or just the parent, or just the amount.

We might also allow the `mix-in` operand to include its current location within the script, so that signatures wrapping the same conditions might need different signatures as different locations within a script.

**TODO** elucidate and consider this further. Maybe hard-code `x0` to be the current input and create an operator `(current-location)` that returns the current location within the script.

## pay to hash

We can simulate a pay-to-hash with something like this:

```scheme
  (
    (reduce x1 x2)
    (equal (hash x1) 0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855)
  )
```

- x0 = the constant value
- x1 = the script that hashes to x0
- x2 = the solution to x1

This will allow the script to be hidden as a preimage of a hash until the coins are redeemed. Coins will be encumbered by pay-to-hashes that look like this, so that the "pay-to" field of an output is a fixed size of 256 bits.

This is another good candidate for a macro.

```scheme
  (macro (pay-to-hash x10 x0 x1)
    (reduce x0 x1)
    (equal (hash x0) x10)
  )
```


## trust funds

If we create an operator that builds up inputs from its constituent parts (hash and coin value), in conjunction with a `assert_confirm_timestamp_exceeds` condition and `confirmation_timestamp` we can create a "trust fund" contract that limits the rate at which coins can be withdrawn.

In this example, 100000 coins can be withdrawn every 86400 seconds.

```scheme
  (
  ; taproot signature
   (pay_to_taproot 0x0317f1d3a73197d7942695638c4...86c55e83ff97a1aeffb3af00adb22c6bb x0 x1 x2 x3 x4 x5 x6)
  ; let x7, x8, x9 be current input components
   (equal (current_input) (make_output x7 x8 x9))
  ; let x10, x11, x12 be the new replacement trust fund output
   (assert_output (make_output x10 x11 x12))
  ; make sure the new pay-to output is the same as the old
   (equal x8 x11)
  ; make sure we waited long enough
   (assert_confirm_timestamp_exceeds (+ confirmation_timestamp 86400))
  ; make sure we put enough coins into the new contract
   (<= 0 (- x9 x12) 100000) ; these values must be non-decreasing
  )
```

New operators:

- `(make_output unique_nonce pay_to_address coin_amount)`
- `(current_input)`
- `(assert_confirm_timestamp_exceeds)` similar to bitcoin's `CHECKLOCKTIME`
- `(<= x0 x1 x2 x3)` True iff `x0 <= x1 <= x2 <= x3` as integer values

- `x0 - x6` = taproot solution
- `x7, x8, x9` = constituent components of current input (nonce, address, coin amount)
- `x10, x11, x12` = constituent components of new output ensuring the contract lives on

This contract is not perfect. We need more logic to cleanly handle the case where the contract ends, ie. the input has fewer than 100000 coins remaining and we withdraw them all, and don't need the output.

## CLAVZ

A test of the completeness of a system to encumber funds is to determine how to write a class of various different useful contracts. We use the CLAVZ suite: custody, lightning (federated payment channels), atomic swaps (coins move only upon a reveal of a preimage or a private key), vaults, and zero-collateral lotteries.


### expiring lock-up

We define a macro which will be useful for contracts that have two cases: a "payable now" clause and a "payable after time T" clause.

```scheme
  (macro (timelock x0 x1 x2)
    (choose1
      x0
      (
        x1
        (assert_confirm_timestamp_exceeds x2)
      )
    )
  )
```

- `x0` = script for payable now
- `x1` = script for payable after time T
- `x2` = time T


### custody

In this contract, coins are owned by one entity with a private key, but held by another entity.


### lightning



### atomic swaps

If the underlying currency has a type modifier associated with a coin, atomic swaps look like any other transaction.

A and B want to swap an asset atomically. They exchange public keys P_A and P_B. A generates a nonce N and sends the hash H_N to B. A protects his asset with the following script:

```scheme
(choose1 x0
 (
   (pay_to_pubkey P_B x1 x2)
   (equal H_N (hash x8))
 )
 (
   (pay_to_pubkey P_A x1 x2)
   (assert_confirm_timestamp_exceeds 864000)
 )
)
```

or perhaps slightly more readably using the `timelock` macro,

```scheme
(timelock
  (
    (pay_to_pubkey P_B x1 x2 x3)
    (equal H_N (hash x8))
  )
  (pay_to_pubkey P_A x1 x2 x3)
  864000
)
```

After confirmation, B can inspect that he has sole ability to move the asset for 864000 seconds, after which A can claw it back. So B produces a similar script, except with a smaller timeout. Then A can grab the asset from B, revealing the nonce in `x8`, allowing B to grab the asset from A.

This works across blockchains too, as long as they have a hash function in common.


### sticky conditions

With the addition of a few operators, we show that we can impose very specific conditions on outputs, including conditions on outputs arbitrarily deep.

We define the `compile` and `unescape` operator to build parameterized scripts at runtime: `compile` prevents substitution of free variables except those marked by `unescape`. Here's an example:

```scheme
(
  (assert_output (make_output (
    x0
    (hash
      (compile
        (choose1 x0
          (
            (assert_confirm_timestamp_exceeds 86400)
            (unescape x1)
          )
          (pay_to_pubkey 0x0317f1d3a73197d7942695638c4...86c55e83ff97a1aeffb3af00adb22c6bb x1 x2 x3)
        )
      )
    )
    x2)))
)
```

- `x0`: the output nonce
- `x1`: the script fragment that can only unencumber funds after 86400 seconds
- `x2`: the output amount

If this condition is included, then an output of value x2 must be created, and it must have a pay-to of the form given. The owner of the pubkey will then know they are able to claw back the funds if necessary. At spend-time, the x1 witness must be a script fragment.

This is pretty confusing due to name collision. One thing to note is that the internal instance of the `x0-x3` variables, those variables don't come into scope until the *next* output is spent.

We create a macro to encapsulate this functionality too.

```scheme
(macro (enforce-clawback-timelock x0 x1 x2 x3 x4 delay clawback_script))
  (
    (is_equal (current_input) (make_input x0 x1 x2))
    (assert_output (make_output (
      x3
      (hash
        (compile
          (choose1 x0
            (
              (assert_confirm_timestamp_exceeds delay)
              (unescape x4)
            )
            clawback_script
          )
        )
      )
      x2)))
  )
)
```

The `assert_output` ensures that the output is of a certain FORM. One subnode `(unescape x4)` is parameterized, and not fully specified. But it's gated by a locktime.

** This syntax is a mess. There might be a more clear or more standardized way of doing this. **

- `clawback_script`: the script that is guaranteed to be in the output when this input is spent
- `delay`: the delay before the alternative contract can spend the output
- `x0`: the input script nonce
- `x1`: the input script pay-to-script hash
- `x2`: the input script coin value
- `x3`: the blessed output nonce
- `x4`: the blessed output script fragment that can be used after the given delay


### vaults

This contract ensure that coins removed from the contract are held in limbo for a predetermined amount of time before becoming completely unencumbered; while in this limbo, the coins can be clawed back using a different "more private" private key.



### zero collateral lotteries

This contract allows two or more users lock up coins in an address, and after a predetermined deadline, one user gains access to all the coins randomly. Ideally, the probability of winning is proportional to the amount locked up. In the simplest case, two users A and B each send the same amount.

The main trick is that each of A and B generate a private nonce N_A and N_B, and hash them to H_A and H_B. A gets "heads" and B gets "tails", where the coin flip is determined by the low bit of the hash of the pre-images (or whatever).

A and B must also share public keys P_A and P_B (or more generally, encumbrance script fragments S_A and S_B).

We declare a macro that we will reuse.

```scheme
(macro claim_funds_with_hash_reveal (x0 x1 x2 x3 x4)
  (
    (is_equal H_A (hash x0))
    (is_equal H_B (hash x1))
    (is_equal x2 (& 1 (hash x0 x1)))
    (choose1 x2
      (pay_to_pubkey P_A x3 x4)
      (pay_to_pubkey P_B x3 x4)
    )
  )
)
```

This macro hashes the two pre-images together, and allows P_A to be used if the low-bit of the hash is set or P_B if not.

We must deal with the case where B's pre-image is unknown. A should still be able to claim the funds, but allow time for B to sweep them. By symmetry, we need to go the other way too, so we write a macro.

```scheme
(macro claim_funds_unilaterally (pubkey hash_of_nonce x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12)
  (
    (pay_to_pubkey pubkey x0 x1)
    (enforce-clawback-timelock (x2 x3 x4 x5 x6 86400
      (claim_funds_with_hash_reveal (x7 x8 x9 x10 x11))
      )
    )
    (is_equal hash_of_nonce (hash x12))
  )
)
```

And here is the final script.

```
(choose1 x0
  (claim_funds_unilaterally P_A H_A x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13)
  (claim_funds_unilaterally P_B H_B x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13)
  (claim_funds_with_hash_reveal x1 x2 x3 x4 x5)
)
```

Technically, we don't even need the last clause, since if A and B reveal offline, the winner can be decided, and can keep the money in this complex contract secure in the knowledge that the loser cannot claw it back.

(Ideally, the whole thing can be hidden in a taproot so the blockchain doesn't even need to know about it.)


This can likely be improved.



### solving puzzle scripts


## creating witnesses without too much blow-up

We have a list of expressions `e0, e1, e2... e_n` that eventually get bound to `x0, x1..., x_n`. `e0` must be a contant, but `e1` is evaluated in the context of `e0`, so if there are redundancies between `e0` and `e1`, we can use operators to calculate one from the other.

Often, `e0` will be the constant hash expansion, which is an S-expression, so `e1` can drill down and pull out subexpressions using `extract`.

```scheme
  (extract x0 (1 5 1)) ; choose the first element of the fifth element of the first element from x0
```

## gas

- a limit on how many opcodes are run as a function of fees, to remove potential denial-of-service attacks via repeated use of `(reduce x0 x1)`


<!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js"></script><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>